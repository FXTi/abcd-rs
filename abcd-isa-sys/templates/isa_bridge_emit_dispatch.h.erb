// Autogenerated file -- DO NOT EDIT!
// Dispatch switch for isa_emitter_emit(): maps opcode to BytecodeEmitter method.

switch (static_cast<Inst::Opcode>(opcode)) {
% Panda::instructions.group_by(&:mnemonic).each do |mnemonic, group|
%   emitter_name = group.first.emitter_name
%   is_jump = group.first.jump?
%   signature = emitter_signature(group, is_jump)
%
%   # Build the call arguments list
%   call_args = []
%   signature.each_with_index do |o, i|
%     if o.type == 'const Label &'
%       call_args << "e->labels[static_cast<uint32_t>(args[#{i}])]"
%     else
%       call_args << "static_cast<#{o.type}>(args[#{i}])"
%     end
%   end
%
%   # Emit case labels for all opcodes in this mnemonic group
%   group.each do |insn|
case Inst::Opcode::<%= insn.opcode.upcase %>:
%   end
%   if is_jump
    if (num_args < <%= signature.size %>) return ISA_EMIT_TOO_FEW_ARGS;
    if (args[<%= signature.size - 1 %>] < 0 ||
        static_cast<size_t>(args[<%= signature.size - 1 %>]) >= e->labels.size()) return ISA_EMIT_INVALID_LABEL;
%   elsif !signature.empty?
    if (num_args < <%= signature.size %>) return ISA_EMIT_TOO_FEW_ARGS;
%   end
    e->emitter.<%= emitter_name %>(<%= call_args.join(', ') %>);
    return ISA_EMIT_OK;
% end
default:
    return ISA_EMIT_UNKNOWN_OPCODE;
}
