// Autogenerated file -- DO NOT EDIT!
// Generated from isa.yaml via bytecode.rs.erb

// ============================================================================
// Operand types
// ============================================================================

/// Virtual register operand (field width: 4/8/16 bit).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct Reg(pub u16);

impl std::fmt::Display for Reg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "v{}", self.0)
    }
}

/// Immediate operand (signed 64-bit to cover all widths).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct Imm(pub i64);

impl std::fmt::Display for Imm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Constant pool entity ID (method_id / string_id / literalarray_id / etc.).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct EntityId(pub u32);

impl std::fmt::Display for EntityId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Instruction index handle for jump targets.
///
/// In decoded bytecode, the inner value is the index of the target
/// instruction in the returned slice. When constructing instructions
/// for encoding, the inner value is the target instruction index in
/// the input slice.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct Label(pub u32);

impl std::fmt::Display for Label {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "label_{}", self.0)
    }
}

// ============================================================================
// Property flags
// ============================================================================

bitflags::bitflags! {
    /// Property flags for [`Bytecode::has_flag`].
    ///
    /// Values match the C++ `BytecodeInstruction::Flags` enum generated from `isa.yaml`.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    pub struct BytecodeFlag: u32 {
% Panda::properties.each_with_index do |f, i|
        const <%= f.tag.upcase %> = <%= format("0x%x", 1 << i) %>;
% end
    }
}

// ============================================================================
// Exception types
// ============================================================================

bitflags::bitflags! {
    /// Exception type masks for [`Bytecode::is_throw_ex`].
    ///
    /// Values match the C++ `Exceptions` enum generated from `isa.yaml`.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    pub struct ExceptionType: u32 {
% Panda::exceptions.each_with_index do |f, i|
        const <%= f.tag.upcase %> = <%= format("0x%x", 1 << i) %>;
% end
    }
}

// ============================================================================
// Bytecode enum
// ============================================================================

<%
  # Helper: convert mnemonic to CamelCase variant name
  # "deprecated.ldlexenv" -> "DeprecatedLdlexenv"
  # "mov.64" -> "MovWide"
  def mnemonic_variant_name(mnemonic)
    mnemonic.split('.').map { |p| p == '64' ? 'Wide' : p.capitalize }.join
  end

  # Group instructions by mnemonic (per-mnemonic variants)
  mnemonic_groups = Panda.instructions.group_by(&:mnemonic)

  # Helper: Rust type for operand in Bytecode variant
  def rust_variant_type(op, is_jump)
    if is_jump && op.imm?
      'Label'
    elsif op.reg?
      'Reg'
    elsif op.id?
      'EntityId'
    else
      'Imm'
    end
  end

  # Compute max operand count across all mnemonics
  max_operands = mnemonic_groups.values.map { |g| g.first.operands.size }.max || 0
%>

/// Decoded ArkCompiler bytecode instruction.
///
/// Each variant represents a mnemonic (e.g. `Mov` merges `MOV_V4_V4`,
/// `MOV_V8_V8`, `MOV_V16_V16`). Operands are stored as decoded typed fields.
#[derive(Clone, Copy)]
pub enum Bytecode {
% mnemonic_groups.each do |mnemonic, group|
%   vname = mnemonic_variant_name(mnemonic)
%   is_jump = group.first.jump?
%   ops = group.first.operands
%   fields = ops.map { |op| rust_variant_type(op, is_jump) }
%   opcodes_hex = group.map { |i| format('0x%04x', i.opcode_idx) }.join('/')
%   if fields.empty?
    /// `<%= mnemonic %>` (opcodes: <%= opcodes_hex %>)
    <%= vname %>,
%   else
    /// `<%= mnemonic %>` (opcodes: <%= opcodes_hex %>)
    <%= vname %>(<%= fields.join(', ') %>),
%   end
% end
}

// ============================================================================
// Bytecode methods
// ============================================================================

impl Bytecode {
    /// Representative opcode for this mnemonic (largest format).
    ///
    /// Used internally for FFI classification calls and emitter dispatch.
    /// All opcodes in a mnemonic group share the same properties, so the
    /// specific value does not matter.
    fn representative_opcode(&self) -> u16 {
        match self {
% mnemonic_groups.each do |mnemonic, group|
%   vname = mnemonic_variant_name(mnemonic)
%   largest = group.max_by { |i| i.format.size }
            Bytecode::<%= vname %><%= group.first.operands.empty? ? '' : '(..)' %> => <%= largest.opcode_idx %>,
% end
        }
    }

    /// Mnemonic name (e.g. `"mov"`, `"jmp"`).
    pub fn mnemonic(&self) -> &'static str {
        match self {
% mnemonic_groups.each do |mnemonic, group|
%   vname = mnemonic_variant_name(mnemonic)
            Bytecode::<%= vname %><%= group.first.operands.empty? ? '' : '(..)' %> => "<%= mnemonic %>",
% end
        }
    }

    // === Classification (delegates to opcode-based C FFI) ===

    /// Check if this instruction is a jump.
    pub fn is_jump(&self) -> bool {
        unsafe { crate::isa_is_jump_opcode(self.representative_opcode()) != 0 }
    }

    /// Check if this instruction can throw an exception.
    pub fn can_throw(&self) -> bool {
        unsafe { crate::isa_can_throw_opcode(self.representative_opcode()) != 0 }
    }

    /// Check if this instruction is a block terminator.
    pub fn is_terminator(&self) -> bool {
        unsafe { crate::isa_is_terminator_opcode(self.representative_opcode()) != 0 }
    }

    /// Check if this instruction has a specific property flag.
    ///
    /// ```ignore
    /// use abcd_isa_sys::BytecodeFlag;
    /// if bc.has_flag(BytecodeFlag::CALL | BytecodeFlag::DYNAMIC) { /* ... */ }
    /// ```
    pub fn has_flag(&self, flag: BytecodeFlag) -> bool {
        unsafe { crate::isa_has_flag_opcode(self.representative_opcode(), flag.bits()) != 0 }
    }

    /// Check if this instruction is a range instruction.
    pub fn is_range(&self) -> bool {
        unsafe { crate::isa_is_range_opcode(self.representative_opcode()) != 0 }
    }

    /// Check if this instruction is a return or throw.
    pub fn is_return_or_throw(&self) -> bool {
        unsafe { crate::isa_is_return_or_throw_opcode(self.representative_opcode()) != 0 }
    }

    /// Check if this instruction is a suspend point (generator/async yield).
    pub fn is_suspend(&self) -> bool {
        unsafe { crate::isa_is_suspend_opcode(self.representative_opcode()) != 0 }
    }

    /// Check if this instruction throws a specific exception type.
    ///
    /// ```ignore
    /// use abcd_isa_sys::ExceptionType;
    /// if bc.is_throw_ex(ExceptionType::X_NULL | ExceptionType::X_BOUNDS) { /* ... */ }
    /// ```
    pub fn is_throw_ex(&self, mask: ExceptionType) -> bool {
        unsafe { crate::isa_is_throw_ex_opcode(self.representative_opcode(), mask.bits()) != 0 }
    }

    // === Emitter support ===

    /// Extract opcode and operand values for the emitter.
    ///
    /// Returns `(opcode, args, num_args)` where `args` contains operand values
    /// as `i64` in instruction operand order. For jump instructions, the
    /// Label operand holds the label ID.
    pub fn emit_args(&self) -> (u16, [i64; <%= max_operands %>], usize) {
        let op = self.representative_opcode();
        let mut args = [0i64; <%= max_operands %>];
        let n = match *self {
% mnemonic_groups.each do |mnemonic, group|
%   vname = mnemonic_variant_name(mnemonic)
%   is_jump = group.first.jump?
%   ops = group.first.operands
%   if ops.empty?
            Bytecode::<%= vname %> => 0,
%   else
%     pat_vars = []
%     assignments = []
%     ops.each_with_index do |op, i|
%       vn = "a#{i}"
%       pat_vars << vn
%       if is_jump && op.imm?
%         assignments << "args[#{i}] = #{vn}.0 as i64;"
%       elsif op.reg?
%         assignments << "args[#{i}] = #{vn}.0 as i64;"
%       elsif op.id?
%         assignments << "args[#{i}] = #{vn}.0 as i64;"
%       else
%         assignments << "args[#{i}] = #{vn}.0;"
%       end
%     end
            Bytecode::<%= vname %>(<%= pat_vars.join(', ') %>) => {
%     assignments.each do |a|
                <%= a %>
%     end
                <%= ops.size %>
            }
%   end
% end
        };
        (op, args, n)
    }

    /// Set the jump target label.
    pub fn set_label(&mut self, label: Label) {
        match self {
% mnemonic_groups.each do |mnemonic, group|
%   next unless group.first.jump?
%   vname = mnemonic_variant_name(mnemonic)
%   ops = group.first.operands
%   label_idx = ops.index { |op| op.imm? }
%   next unless label_idx
%   pats = ops.each_with_index.map { |op, i| i == label_idx ? 'l' : '_' }
            Bytecode::<%= vname %>(<%= pats.join(', ') %>) => *l = label,
% end
            _ => {}
        }
    }

    /// Index of the label operand in [`emit_args`](Self::emit_args) output.
    ///
    /// Returns `Some(idx)` for jump instructions, `None` otherwise.
    pub fn jump_label_arg_index(&self) -> Option<usize> {
        match self {
% mnemonic_groups.each do |mnemonic, group|
%   next unless group.first.jump?
%   vname = mnemonic_variant_name(mnemonic)
%   ops = group.first.operands
%   label_idx = ops.index { |op| op.imm? }
%   next unless label_idx
            Bytecode::<%= vname %>(..) => Some(<%= label_idx %>),
% end
            _ => None,
        }
    }
}

// ============================================================================
// Display / Debug
// ============================================================================

impl core::fmt::Display for Bytecode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "{}", self.mnemonic())?;
        match self {
% mnemonic_groups.each do |mnemonic, group|
%   vname = mnemonic_variant_name(mnemonic)
%   is_jump = group.first.jump?
%   ops = group.first.operands
%   if ops.empty?
            Bytecode::<%= vname %> => Ok(()),
%   else
%     pat_vars = ops.each_with_index.map { |_, i| "a#{i}" }
%     fmt_parts = []
%     ops.each_with_index do |op, i|
%       vn = "a#{i}"
%       if is_jump && op.imm?
%         fmt_parts << "write!(f, \" label_{}\", #{vn}.0)"
%       elsif op.reg?
%         fmt_parts << "write!(f, \" v{}\", #{vn}.0)"
%       elsif op.id?
%         fmt_parts << "write!(f, \" id:{}\", #{vn}.0)"
%       else
%         fmt_parts << "write!(f, \" {}\", #{vn}.0)"
%       end
%     end
            Bytecode::<%= vname %>(<%= pat_vars.join(', ') %>) => {
%     fmt_parts[0...-1].each do |p|
                <%= p %>?;
%     end
                <%= fmt_parts.last %>
            }
%   end
% end
        }
    }
}

impl core::fmt::Debug for Bytecode {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "Bytecode({self})")
    }
}

// ============================================================================
// Single-instruction decode
// ============================================================================

impl Bytecode {
    /// Decode a single instruction from raw bytes.
    ///
    /// Returns `Some((instruction, raw_jump_offset))` on success, or `None`
    /// if the opcode is unknown. For jump instructions, `raw_jump_offset` is
    /// `Some(byte_offset)` (the signed immediate); for non-jumps it is `None`.
    ///
    /// # Safety
    ///
    /// `ptr` must point to at least `isa_get_size_by_opcode(opcode)` readable
    /// bytes. `opcode` must have been obtained from `isa_get_opcode(ptr)`.
    pub unsafe fn decode_one(ptr: *const u8, opcode: u16) -> Option<(Self, Option<i64>)> {
        match opcode as u32 {
% mnemonic_groups.each do |mnemonic, group|
%   vname = mnemonic_variant_name(mnemonic)
%   is_jump = group.first.jump?
%   ops = group.first.operands
%   opcode_literals = group.map { |i| "#{i.opcode_idx}" }
            <%= opcode_literals.join(' | ') %> => {
%   if ops.empty?
                Some((Bytecode::<%= vname %>, None))
%   else
%     type_indices = { reg?: 0, imm?: 0, id?: 0 }
%     field_exprs = []
%     raw_imm_expr = nil
%     ops.each do |op|
%       key = [:reg?, :imm?, :id?].find { |k| op.send(k) }
%       tidx = type_indices[key]
%       type_indices[key] += 1
%       if is_jump && op.imm?
%         raw_imm_expr = "unsafe { crate::isa_get_imm64(ptr, #{tidx}) }"
%         field_exprs << 'Label(0)'
%       elsif op.reg?
%         field_exprs << "Reg(unsafe { crate::isa_get_vreg(ptr, #{tidx}) } as u16)"
%       elsif op.id?
%         field_exprs << "EntityId(unsafe { crate::isa_get_id(ptr, #{tidx}) })"
%       else
%         field_exprs << "Imm(unsafe { crate::isa_get_imm_data(ptr, #{tidx}) })"
%       end
%     end
%     if is_jump && raw_imm_expr
                let raw_imm = <%= raw_imm_expr %>;
                Some((Bytecode::<%= vname %>(<%= field_exprs.join(', ') %>), Some(raw_imm)))
%     else
                Some((Bytecode::<%= vname %>(<%= field_exprs.join(', ') %>), None))
%     end
%   end
            }
% end
            _ => None,
        }
    }
}

// ============================================================================
// Per-mnemonic constructor structs
// ============================================================================

/// Per-mnemonic constructor types.
///
/// Each struct has a `new(...)` method that returns a [`Bytecode`] value.
/// Jump instructions accept [`Label`] instead of [`Imm`] for the offset operand.
pub mod insn {
    use super::*;

% mnemonic_groups.each do |mnemonic, group|
%   vname = mnemonic_variant_name(mnemonic)
%   is_jump = group.first.jump?
%   ops = group.first.operands
%
%   # Build constructor parameters
%   params = []
%   ops.each_with_index do |op, i|
%     pname = "a#{i}"
%     if is_jump && op.imm?
%       params << "#{pname}: Label"
%     elsif op.reg?
%       params << "#{pname}: Reg"
%     elsif op.id?
%       params << "#{pname}: EntityId"
%     else
%       params << "#{pname}: Imm"
%     end
%   end
%   args_list = ops.each_with_index.map { |_, i| "a#{i}" }.join(', ')
    pub struct <%= vname %>;
    impl <%= vname %> {
%   if params.empty?
        pub fn new() -> Bytecode {
            Bytecode::<%= vname %>
        }
%   else
        pub fn new(<%= params.join(', ') %>) -> Bytecode {
            Bytecode::<%= vname %>(<%= args_list %>)
        }
%   end
    }

% end
}
